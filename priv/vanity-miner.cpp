// Adapted from the original C++ code located here:
// https://github.com/bitcoinbook/bitcoinbook/blob/second_edition/code/vanity-miner.cpp
#include <random>
#include <bitcoin/bitcoin.hpp>
#include "vanity-miner.h"

int main() {
  int bytes_read;
  byte buffer[MAX_BUFFER_SIZE];

  // random_device on Linux uses "/dev/urandom"
  // CAUTION: Depending on implementation this RNG may not be secure enough!
  // Do not use vanity keys generated by this example in production
  std::random_device random;
  std::default_random_engine engine(random());

  while ((bytes_read = read_msg(buffer)) > 0) {
    // Loop continuously...
    while (true) {
      // Generate a random secret.
      bc::ec_secret secret = random_secret(engine);
      // Get the address.
      std::string address = bitcoin_address(secret);
      // Does it match our search string? (1kid)
      if (match_found(address, buffer)) {
        // Success!
        memcpy(buffer, address.data(), address.length());
        send_msg(buffer, address.size());

        std::string encoded_secret = bc::encode_base16(secret);
        memcpy(buffer, encoded_secret.data(), encoded_secret.length());
        send_msg(buffer, encoded_secret.size());
        break;
      }
    }
  }

  // Should never reach here!
  return 0;
}

bc::ec_secret random_secret(std::default_random_engine& engine) {
  // Create new secret...
  bc::ec_secret secret;
  // Iterate through every byte setting a random value...
  for (uint8_t& byte: secret) {
    byte = engine() % std::numeric_limits<uint8_t>::max();
  }
  // Return result.
  return secret;
}

std::string bitcoin_address(const bc::ec_secret& secret) {
  // Convert secret to payment address
  bc::wallet::ec_private private_key(secret);
  bc::wallet::payment_address payaddr(private_key);
  // Return encoded form.
  return payaddr.encoded();
}

bool match_found(const std::string& address, const std::string search) {
  auto addr_it = address.begin();
  // Loop through the search string comparing it to the lower case
  // character of the supplied address.
  for (auto it = search.begin(); it != search.end(); ++it, ++addr_it)
    if (*it != std::tolower(*addr_it)) {
      return false;
    }
  // Reached end of search string, so address matches.
  return true;
}
